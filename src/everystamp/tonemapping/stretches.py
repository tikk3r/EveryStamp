from astropy.visualization import BaseStretch
from astropy.visualization.stretch import _prepare
from typing import Optional
import numpy as np


def findrms(mIn, maskSup: float = 1e-7):
    """Find the rms of an array, from Cycil Tasse/kMS"""
    m = mIn[np.abs(mIn) > maskSup]
    rmsold = np.nanstd(m)
    diff = 1e-1
    cut = 3.0
    med = np.nanmedian(m)
    for i in range(10):
        ind = np.where(np.abs(m - med) < rmsold * cut)[0]
        rms = np.nanstd(m[ind])
        if np.abs((rms - rmsold) / rmsold) < diff:
            break
        rmsold = rms
    return rms


class TimmermanStretch(BaseStretch):
    """A stretch originally devised by R. Timmerman to (approximately)
    conserve the visual dynamic range between background noise and source emission.
    """

    @property
    def _supports_invalid_kw(self):
        return True

    def __call__(
        self,
        values: np.ndarray,
        rms_factor: float = 2.5,
        peak_factor: float = 75.0,
        clip: bool = True,
        out: Optional[np.ndarray] = None,
        invalid: Optional[float] = None,
    ):
        """
        Transform values using this stretch.

        Args:
            values : array-like
                The input values, which should already be normalized to the
                [0:1] range.
            clip : bool, optional
                If `True` (default), values outside the [0:1] range are
                clipped to the [0:1] range.
            out : ndarray, optional
                If specified, the output values will be placed in this array
                (typically used for in-place calculations).
            invalid : None or float, optional
                Value to assign NaN values generated by this class.  NaNs in
                the input ``values`` array are not changed.  This option is
                generally used with matplotlib normalization classes, where
                the ``invalid`` value should map to the matplotlib colormap
                "under" value (i.e., any finite value < 0).  If `None`, then
                NaN values are not replaced.  This keyword has no effect if
                ``clip=True``.
            rms_factor : float
                Sets the minimum value of the stretch based on the rms.
            peak_factor : float
                Proxy for the maximum value of the stretch based on the rms.

        Returns:
            result : ndarray
                The transformed values.
        """
        values = _prepare(values, clip=clip, out=out)
        replace_invalid = not clip and invalid is not None
        with np.errstate(invalid="ignore"):
            if replace_invalid:
                idx = values < 0
            rms = findrms(values)
            vmin = -rms_factor * rms
            vmax = np.nanmax((peak_factor * rms, np.nanmax(values)))
            power_scaling = np.log(0.2) / np.log(2 * rms_factor * rms / (vmax - vmin))
            values = values**power_scaling

        if replace_invalid:
            # Assign new NaN (i.e., NaN not in the original input
            # values, but generated by this class) to the invalid value.
            values[idx] = invalid

        return values

    @property
    def inverse(self):
        """A stretch object that performs the inverse operation."""
        raise NotImplementedError
