<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>everystamp.downloaders API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>everystamp.downloaders</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from urllib.request import urlopen

import glob
import os
import subprocess
import sys
import logging

from astropy.coordinates import SkyCoord
from astropy.io import fits
from astropy.nddata import Cutout2D
from astropy.table import Table
from astropy.wcs import WCS
from astropy.wcs.utils import skycoord_to_pixel
from astroquery.hips2fits import hips2fits
from astroquery.skyview import SkyView

import astropy.units as u
import casacore.tables as ct
import numpy as np
import pyvo
import requests
import tqdm


class FileDownloader(object):
    &#39;&#39;&#39; From https://medium.com/better-programming/python-progress-bars-with-tqdm-by-example-ce98dbbc9697
    Copyright 2019 tiptapcode Authors. All Rights Reserved.
    Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
         http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    &#39;&#39;&#39;
    def get_url_filename(self, url):
        &#34;&#34;&#34;
        Discover file name from HTTP URL, If none is discovered derive name from http redirect HTTP content header Location
        :param url: Url link to file to download
        :type url: str
        :return: Base filename
        :rtype: str
        &#34;&#34;&#34;
        try:
            filename = os.path.basename(url)
            basename, ext = os.path.splitext(filename)
            if ext:
                return filename
            header = requests.head(url, allow_redirects=False).headers
            return os.path.basename(header.get(&#39;Location&#39;)) if &#39;Location&#39; in header else filename
        except requests.exceptions.HTTPError as errh:
            print(&#34;Http Error:&#34;, errh)
            raise errh
        except requests.exceptions.ConnectionError as errc:
            print(&#34;Error Connecting:&#34;, errc)
            raise errc
        except requests.exceptions.Timeout as errt:
            print(&#34;Timeout Error:&#34;, errt)
            raise errt
        except requests.exceptions.RequestException as err:
            print(&#34;OOps: Something Else&#34;, err)
            raise err

    def download_file(self, url, filename=None, target_dir=None):
        &#34;&#34;&#34;
        Stream downloads files via HTTP
        :param url: Url link to file to download
        :type url: str
        :param filename: filename overrides filename defined in Url param
        :type filename: str
        :param target_dir: target destination directory to download file to
        :type target_dir: str
        :return: Absolute path to target destination where file has been downloaded to
        :rtype: str
        &#34;&#34;&#34;
        if target_dir and not os.path.isdir(target_dir):
            raise ValueError(&#39;Invalid target_dir={} specified&#39;.format(target_dir))
        local_filename = self.get_url_filename(url) if not filename else filename

        req = requests.get(url, stream=True, verify=True)
        req.raise_for_status()
        try:
            file_size = int(req.headers[&#39;Content-Length&#39;])
        except KeyError:
            if req.headers[&#39;Transfer-Encoding&#39;] == &#39;chunked&#39;:
                file_size = 0
        chunk_size = 1024  # 1 MB
        num_bars = int(file_size / chunk_size)

        base_path = os.path.abspath(os.path.dirname(__file__))
        target_dest_dir = os.path.join(base_path, local_filename) if not target_dir else os.path.join(target_dir, local_filename)
        with open(target_dest_dir, &#39;wb&#39;) as fp:
            for chunk in tqdm.tqdm(req.iter_content(chunk_size=chunk_size), total=num_bars, unit=&#39;KB&#39;, leave=True, file=sys.stdout):
                fp.write(chunk)

        return target_dest_dir


class LegacyDownloader(FileDownloader):
    &#39;&#39;&#39; Downloader sub-class for the DESI Legacy Imaging Surveys.
    &#39;&#39;&#39;
    supported_keywords = [&#39;ra&#39;, &#39;dec&#39;, &#39;mode&#39;, &#39;layer&#39;, &#39;pixscale&#39;, &#39;bands&#39;, &#39;size_pix&#39;]
    logger = logging.getLogger(&#39;EveryStamp:LegacyDownloader&#39;)

    def __init__(self):
        self.url = &#39;https://www.legacysurvey.org/viewer/{mode:s}-cutout/?ra={ra:f}&amp;dec={dec:f}&amp;layer={layer:s}&amp;pixscale={pixscale:.3f}&amp;bands={bands:s}&amp;size={size_pix:d}&#39;

    def format_url(self, ra=None, dec=None, size=None, bands=&#39;grz&#39;, mode=&#39;jpeg&#39;, layer=&#39;ls-dr9&#39;, pixscale=0.262, autoscale=False, **kwargs):
        &#39;&#39;&#39;Returns a properly formatted URL that can be used to obtain a cutout from Legacy.
        &#39;&#39;&#39;
        size_pix = int(size * 3600 / pixscale)
        dlpixscale = pixscale
        dlsize_pix = size_pix
        if (size_pix &gt; 3000) and autoscale:
            # Jump to the next available pixel size by scaling from the (approximate) native pixel scale.
            new_pixscale = pixscale
            new_size_pix = int(size * 3600 / new_pixscale)
            while new_size_pix &gt; 3000:
                new_pixscale += 0.262
                new_size_pix = int(size * 3600 / new_pixscale)
            self.logger.warn(&#39;Image size of {:.2f} deg with pixel scale {:.3f} exceeds server limit of 3000 pixels! Automatically adjusting pixel scale to {:.3f} giving {:d} pixels.&#39;.format(size, pixscale, new_pixscale, new_size_pix), Warning, stacklevel=2)
            dlpixscale = new_pixscale
            dlsize_pix = new_size_pix
        elif size_pix &gt; 3000:
            self.logger.warn(&#39;Image size of {:.2f} deg with pixel scale {:.3f} exceeds server limit of 3000 pixels! Image will be truncated! Use --legacy_autoscale or pass autoscale=True to automatically switch pixel scales.&#39;.format(size, pixscale), Warning, stacklevel=2)
        return self.url.format(ra=ra, dec=dec, size_pix=dlsize_pix, bands=bands, mode=mode, layer=layer, pixscale=dlpixscale)

    def download(self, **kwargs):
        furl = self.format_url(**kwargs)
        self.logger.info(&#39;Downloading cutout from %s&#39;, furl)
        if not kwargs[&#39;ddir&#39;]:
            self.logger.info(&#39;Download directory not specified, downloading to %s instead&#39;, os.getcwd())
            ddir = os.getcwd()
        else:
            ddir = kwargs[&#39;ddir&#39;]
        fname = &#39;legacystamps_{ra:f}_{dec:f}_{layer:s}.{mode:s}&#39;.format(ra=kwargs[&#39;ra&#39;], dec=kwargs[&#39;dec&#39;], layer=kwargs[&#39;layer&#39;], mode=kwargs[&#39;mode&#39;])
        self.download_file(furl, filename=fname, target_dir=ddir)


class PanSTARRSDownloader():
    &#39;&#39;&#39; Downloader sub-class for the VLASS survey.
    &#39;&#39;&#39;
    from panstamps.downloader import downloader as psdownloader

    def __init__(self):
        self.logger = logging.getLogger(&#39;EveryStamp:Pan-STARRSDownloader&#39;)

    def download(self, ra, dec, size, mode=&#39;jpeg&#39;, ddir=&#39;&#39;, bands=&#39;gri&#39;):
        if mode == &#39;jpeg&#39;:
            get_jpeg = True
            get_fits = False
        elif mode == &#39;fits&#39;:
            get_jpeg = False
            get_fits = True
        elif mode == &#39;both&#39;:
            get_jpeg = True
            get_fits = True
        arcsecsize = size * 3600
        self.logger.info(&#39;Downloading cutout from PANSTARRS&#39;)
        d = self.psdownloader(ra=ra, dec=dec, downloadDirectory=ddir or os.getcwd(), fits=get_fits, jpeg=get_jpeg, color=True, singleFilters=True, filterSet=bands, imageType=&#39;stack&#39;, arcsecSize=arcsecsize, log=self.logger)
        fitspath, jpegpath, colorpaths = d.get()
        # Rename the output slightly so the user can find it easier.
        for colorpath in colorpaths:
            os.rename(colorpath, os.path.join(os.path.dirname(colorpath),  &#39;panstamps_&#39; + os.path.basename(colorpath)))


class VLASSDownloader(FileDownloader):
    &#39;&#39;&#39; Downloader sub-class for the VLASS survey.

    Based on the original code by Anna Ho (https://github.com/annayqho/Query_VLASS) and edits by R. Timmerman.
    &#39;&#39;&#39;
    def __init__(self):
        self.summary_url = &#39;https://archive-new.nrao.edu/vlass/VLASS_dyn_summary.php&#39;
        self.logger = logging.getLogger(&#39;EveryStamp:VLASSDownloader&#39;)
        self.pixel_scale = 1.0  # arcsec / pixel

    def get_tiles(self, summary_file=&#39;VLASS_dyn_summary.php&#39;):
        &#39;&#39;&#39;
        Read tiles from tile catalog. If file missing, try wget https://archive-new.nrao.edu/vlass/VLASS_dyn_summary.php

        Parameters
        ----------
        summary_file : str
            Location where the VLASS summary file is located.

        Returns
        -------
        tab : astropy Table
            Table containing tile information.
        &#39;&#39;&#39;
        if not os.path.isfile(summary_file):
            self.logger.warn(f&#39;Could not find VLASS summary file {summary_file}!&#39;)
            self.logger.info(&#39;Attempting to download VLASS summary file&#39;)
            subprocess.run([&#39;wget&#39;, &#39;https://archive-new.nrao.edu/vlass/VLASS_dyn_summary.php&#39;, &#39;-O&#39;, summary_file])
        
        # Put it in a more managable format by replacing consecutive white space with commas.
        # Assumes no more than 1 space in valid entries.
        subprocess.run([&#39;sed&#39;, &#39;-i&#39;, &#39;-e&#39;, r&#39;s/ \{2,\}/,/g&#39;, summary_file], check=True)

        tab = Table.read(summary_file, data_start=3, format=&#39;ascii.csv&#39;)
        tab.rename_column(&#39;Observing&#39;, &#39;Epoch&#39;)
        tab.rename_column(&#39;Observation&#39;, &#39;Date&#39;)
        return tab

    def search_tiles(self, tiles, c):
        &#39;&#39;&#39; Search the tile catalog for tiles containing the input coordinate

        Parameters
        ----------
        tiles : astropy Table
            Tile catalogue as obtained from get_tiles()
        c : SkyCoord
            Location to check for coverage in one of the observed tiles.

        Returns
        -------
        tile name : str
            Best matching tile.
        observing epoch : str
            Epoch the best matching tile was observed in.
        observing date : str
            Date the best matching tile was observed at.
        &#39;&#39;&#39;
        ra_h = c.ra.hour
        dec_d = c.dec.deg

        has_dec = np.logical_and(dec_d &gt;= tiles[&#39;Dec min&#39;], dec_d &lt; tiles[&#39;Dec max&#39;])
        has_ra = np.logical_and(ra_h &gt;= tiles[&#39;RA min&#39;], ra_h &lt; tiles[&#39;RA max&#39;])
        in_tile = np.logical_and(has_ra, has_dec)
        name = tiles[&#39;Tile&#39;][in_tile]
        epoch = tiles[&#39;Epoch&#39;][in_tile]
        date = tiles[&#39;Date&#39;][in_tile]    
        if len(name) == 0:
            raise IndexError(&#34;Zero VLASS tiles available for the given coordinate&#34;)
        c_grid = SkyCoord(7.5*(tiles[&#39;RA min&#39;][in_tile] + tiles[&#39;RA max&#39;][in_tile]), 0.5 * (tiles[&#39;Dec min&#39;][in_tile] + tiles[&#39;Dec max&#39;][in_tile]), unit=&#39;deg&#39;, frame=&#39;icrs&#39;)
        dist = c_grid.separation(c)
        best_idx = np.argmin(dist)
        return name[best_idx], epoch[best_idx], date[best_idx]

    def get_subtiles(self, tilename, epoch, consider_QA_rejected):
        &#39;&#39;&#39; For a given tile name, get the subtile filenames in the VLASS directory

        Parse those filenames and return a list of subtile RA and Dec.
        RA and Dec returned as a SkyCoord object

        Parameters
        ----------
        tilename : str
            Name of the tile to extract a subtile from.
        epoch : str
            The epoch the tile was observed in.
        consider_QA_rejected : bool
            Also consider tiles that did not pass the quality assurance checks.

        Returns
        -------
        fname : str
            Name of the subtile.
        c : astropy SkyCoord
            Coordinate of the subtile.
        &#39;&#39;&#39;

        # Obtain the HTML for the given tile
        if &#39;2.1&#39; in epoch:
            self.logger.info(f&#39;Downloading from https://archive-new.nrao.edu/vlass/quicklook/{epoch}/{tilename}&#39;)
            urlpath = urlopen(f&#34;https://archive-new.nrao.edu/vlass/quicklook/{epoch}/{tilename}&#34;)
        else:
            self.logger.info(f&#39;Downloading from https://archive-new.nrao.edu/vlass/quicklook/{epoch}v2/{tilename}&#39;)
            urlpath = urlopen(f&#34;https://archive-new.nrao.edu/vlass/quicklook/{epoch}v2/{tilename}&#34;)
        string = urlpath.read().decode(&#39;utf-8&#39;).split(&#34;\n&#34;)

        if consider_QA_rejected:
            # Obtain the HTML for the QA Rejected
            urlpath_rejected = urlopen(f&#34;https://archive-new.nrao.edu/vlass/quicklook/{epoch}v2/QA_REJECTED&#34;)
            string += urlpath_rejected.read().decode(&#39;utf-8&#39;).split(&#34;\n&#34;)

        # Select only the subtile parts
        vals = np.array([val.strip() for val in string if (&#34;href&#34; in val.strip()) and (tilename in val.strip())])

        # Select the coordinate part. You want the &#39;VLASS1.1.ql.T25t12.J150000+603000.10.2048.v1/&#39; bit
        fname = np.array([val.split(&#34;\&#34;&#34;)[7] for val in vals])

        # Split out the actual coordinate string
        pos_raw = np.array([val.split(&#34;.&#34;)[4] for val in fname])

        if &#39;-&#39; in pos_raw[0]:
            # dec &lt; 0
            ra_raw = np.array([val.split(&#34;-&#34;)[0] for val in pos_raw])
            dec_raw = np.array([val.split(&#34;-&#34;)[1] for val in pos_raw])
        else:
            # dec &gt; 0
            ra_raw = np.array([val.split(&#34;+&#34;)[0] for val in pos_raw])
            dec_raw = np.array([val.split(&#34;+&#34;)[1] for val in pos_raw])
        ra = []
        dec = []
        for ii,val in enumerate(ra_raw):
            if val[1:3] == &#39;24&#39;:
                rah = &#39;00&#39;
            else:
                rah = val[1:3]
            ra.append(f&#34;{rah}h{val[3:5]}m{val[5:]}s&#34;)
            dec.append(f&#34;{dec_raw[ii][:2]}d{dec_raw[ii][2:4]}m{dec_raw[ii][4:]}s&#34;)
        ra = np.array(ra)
        dec = np.array(dec)
        c = SkyCoord(ra, dec, frame=&#39;icrs&#39;)#.directional_offset_by(45*u.deg, 0.75*u.deg)
        return fname, c

    def get_cutout(self, imname, c, crop_scale):
        &#39;&#39;&#39; Get a smaller cutout from the subtile.
        
        Parameters
        ----------
        imname : str
            Name of the image to make a cutout from.
        c : astropy SkyCoord
            Coordinate around which to make a cutout.
        crop_scale : int
            Size of the cutout in pixels.

        Returns
        -------
        output_fits : str
            Name of the output FITS file.
        &#39;&#39;&#39;
        # Define output name
        output_fits = imname.rstrip(&#39;.fits&#39;) + &#39;_poststamp.fits&#39;
        
        # Get header info
        hdu_list = fits.open(imname)
        header = hdu_list[0].header
        data = hdu_list[0].data[0,0,:,:]
        
        # Obtain header and drop useless axes
        wcs = WCS(header)
        wcs = wcs.dropaxis(2).dropaxis(2)
        
        pixel_coords = skycoord_to_pixel(SkyCoord(c.ra.deg, c.dec.deg, unit=&#39;deg&#39;, frame=&#39;icrs&#39;), wcs)
        
        if pixel_coords[0] &lt; 0  or pixel_coords[1] &lt; 0 or pixel_coords[0] &gt; data.shape[0]  or pixel_coords[1] &gt; data.shape[1]:
            subprocess.call(f&#39;rm -f {imname}&#39;, shell=True)
            raise Exception(&#39;Requested coordinate not within the available subtiles. Consider running with consider_QA_rejected=True to also search additional subtiles which failed initial QA checks&#39;)
            
        # Produce a cutout
        cutout = Cutout2D(data, c, (crop_scale, crop_scale), wcs=wcs)
            
        # Update the HDU
        hdu_list[0].data = cutout.data
        new_header = cutout.wcs.to_header()
        hdu_list[0].header.update(new_header)
        hdu_list[0].header.set(&#39;NAXIS&#39;, 4)
        hdu_list[0].header.insert(&#39;NAXIS2&#39;, (&#39;NAXIS3&#39;, 1), after=True)
        hdu_list[0].header.insert(&#39;NAXIS3&#39;, (&#39;NAXIS4&#39;, 1), after=True)
        hdu_list[0].header.remove(&#39;WCSAXES&#39;, ignore_missing=True)
        hdu_list[0].header.remove(&#39;MJDREF&#39;, ignore_missing=True)
        hdu_list[0].header.remove(&#39;MJD-OBS&#39;, ignore_missing=True)
        
        # Write the new fits
        hdu_list.writeto(output_fits, overwrite=True)
        
        # Cleanup
        subprocess.call(f&#34;rm -f {imname}&#34;, shell=True)

        return output_fits

    def search_vlass(self, c, crop=False, crop_scale=256, consider_QA_rejected=False, ddir=os.getcwd()):
        &#34;&#34;&#34; 
        Searches the VLASS catalog for a source

        Parameters
        ----------
        c : astropy SkyCoord
            Coordinate to search for in tiles.
        crop : bool
            Make a cropped cutout of the area of interest.
        crop_scale : int
            Crop the cutout to this amount of pixels centred around c.
        consider_QA_rejected : bool
            Also consider tiles that failed the Quality Assurance checks.
        ddir : str
            Location to download the cutout to.

        Returns
        -------
        imname : str
            Name of the output image.
        &#34;&#34;&#34;
        # Find the VLASS tile
        tiles = self.get_tiles()
        tilename, epoch, obsdate = self.search_tiles(tiles, c)

        subtiles, c_tiles = self.get_subtiles(tilename, epoch, consider_QA_rejected)
        dist = c.separation(c_tiles)
        subtile = subtiles[np.argmin(dist)]

        imname = f&#34;{subtile[:-1]}.I.iter1.image.pbcor.tt0.subim.fits&#34;
        if len(glob.glob(imname)) == 0:
            if &#39;2.1&#39; in epoch:
                url_get = f&#34;https://archive-new.nrao.edu/vlass/quicklook/{epoch}/{tilename}/{subtile}&#34;
            else:
                url_get = f&#34;https://archive-new.nrao.edu/vlass/quicklook/{epoch}v2/{tilename}/{subtile}&#34;
            fname = f&#34;{url_get}{imname}&#34;
            self.logger.info(&#39;Downloading to &#39; + ddir)
            self.download_file(fname, target_dir=ddir)
            if consider_QA_rejected:
                if &#39;2.1&#39; in epoch:
                    url_get = f&#34;https://archive-new.nrao.edu/vlass/quicklook/{epoch}/QA_REJECTED/{subtile}&#34;
                else:
                    url_get = f&#34;https://archive-new.nrao.edu/vlass/quicklook/{epoch}v2/QA_REJECTED/{subtile}&#34;
                fname = f&#34;{url_get}{imname}&#34;
                self.download_file(fname, target_dir=ddir)
        if crop:    
            out = self.get_cutout(os.path.join(ddir, imname), c, crop_scale=crop_scale)
            return out
        else:
            return imname

    def download(self, ra=0.0, dec=0.0, size=0.1, ms=&#39;&#39;, crop=True, consider_QA_rejected=False, ddir=os.getcwd()):
        &#39;&#39;&#39; Download a cutout from the VLASS survey.

        Parameters
        ----------
        ra : float
            Right ascension of the coordinate of interest.
        dec : float
            Declination of the coordinate of interest.
        size : float
            Size of the area of interest in degrees.
        ms : str
            Path to a Measurement Set to take coordinates from instead of using ra and dec.
        crop : bool
            Crop the image to the area of interest.
        consider_QA_rejected : bool
            Also consider tiles that failed the Quality Assurance checks.
        ddir : str
            Location to download the cutout to.
        &#39;&#39;&#39;
        if ms:
            with ct.table(ms.rstrip(&#39;/&#39;) + &#39;::FIELD&#39;) as field:
                direction = field.getcol(&#39;PHASE_DIR&#39;).squeeze()
            ra = (direction[0] % (2 * np.pi)) / np.pi * 180
            dec = direction[1] / np.pi * 180

        c = SkyCoord(ra, dec, unit=&#39;deg&#39;)
        
        crop_scale = size * 3600 / self.pixel_scale
        self.logger.info(&#39;Downloading cutout from VLASS&#39;)
        self.search_vlass(c, crop=crop, crop_scale=crop_scale, consider_QA_rejected=consider_QA_rejected, ddir=ddir)


class VODownloader():
    &#39;&#39;&#39; Downloader sub-class for surveys offeret through a VO.
    &#39;&#39;&#39;
    def __init__(self, url, name=&#39;&#39;):
        if not url:
            raise ValueError(&#39;VO url cannot be empty.&#39;)
        else:
            self.url = url
        if not name:
            self.name = self.url
            self.logger = logging.getLogger(&#39;EveryStamp:VODownloader&#39;)
        else:
            self.name = name
            self.logger = logging.getLogger(&#39;EveryStamp:VODownloader[{:s}]&#39;.format(self.name))

    def download(self, ra=0.0, dec=0.0, size=0.1, ddir=os.getcwd(), suffix=&#39;&#39;):
        &#39;&#39;&#39; Download a cutout from the VLASS survey.

        Parameters
        ----------
        ra : float
            Right ascension of the coordinate of interest in degrees.
        dec : float
            Declination of the coordinate of interest in degrees    .
        size : float
            Size of the area of interest in degrees.
        ddir : str
            Location to download the cutout to.
        &#39;&#39;&#39;
        c = SkyCoord(ra, dec, unit=&#39;deg&#39;)
        
        vo = pyvo.sia.SIAService(self.url)
        query = vo.search(c, size=size)
        if not query:
            raise ValueError(&#39;Requested coordinates not covered by the specified VO!&#39;)
        im = query.getrecord(0)
        if im.format == &#39;image/fits&#39;:
            self.logger.info(&#39;Downloading cutout from {:s}&#39;.format(self.name))
            im.cachedataset(os.path.join(ddir, &#39;{:s}_{:.4f}_{:.4f}_{:.3f}.fits&#39;.format(self.name, ra, dec, size)))


class HiPSDownloader():
    &#39;&#39;&#39; Sub-class to download a file from a HiPS image using hips2fits.
    &#39;&#39;&#39;
    def __init__(self, hips, name=&#39;&#39;):
        if not hips:
            raise ValueError(&#39;HiPS name cannot be empty.&#39;)
        else:
            self.hips = hips
        if not name:
            self.name = self.hips
            self.logger = logging.getLogger(&#39;EveryStamp:VODownloader&#39;)
        else:
            self.name = name
            self.logger = logging.getLogger(&#39;EveryStamp:HiPSDownloader[{:s}]&#39;.format(self.name))

    def download(self, ra=0.0, dec=0.0, size=0.1, ddir=os.getcwd(), pixsize=1.0, mode=&#39;jpg&#39;):
        &#39;&#39;&#39; Download a cutout from the VLASS survey.

        Parameters
        ----------
        ra : float
            Right ascension of the coordinate of interest in degrees.
        dec : float
            Declination of the coordinate of interest in degrees    .
        size : float
            Size of the area of interest in degrees.
        ddir : str
            Location to download the cutout to.
        pixsize : float
            Pixel scale of the survey in arcsec. Default is 1.0 arcsec per pixel.
        mode : str
            What image format to download. Can be jpg or fits, default is jpg.
        &#39;&#39;&#39;
        imsize = int(size / (pixsize / 3600))
        img = hips2fits.query(hips=self.hips, format=mode, width=imsize, height=imsize, projection=&#39;SIN&#39;, fov=size*u.deg, ra=ra*u.deg, dec=dec*u.deg)
        if mode == &#39;jpg&#39;:
            from PIL import Image
            imdata = Image.fromarray(img)
            imdata.save(os.path.join(ddir, &#39;{:s}_{:.4f}_{:.4f}_{:.3f}.jpeg&#39;.format(self.name, ra, dec, size)))
        elif mode == &#39;fits&#39;:
            img.writeto(os.path.join(ddir, &#39;{:s}_{:.4f}_{:.4f}_{:.3f}.fits&#39;.format(self.name, ra, dec, size)))


class SkyViewDownloader():
    &#39;&#39;&#39; Downloader sub-class for surveys offeret through a VO.
    &#39;&#39;&#39;
    def __init__(self, survey):
        if not survey:
            raise ValueError(&#39;SkyView survey cannot be empty.&#39;)
        else:
            self.survey = survey
            self.logger = logging.getLogger(&#39;EveryStamp:SkyViewDownloader[{:s}]&#39;.format(self.survey))

    def download(self, ra=0.0, dec=0.0, size=0.1, ddir=os.getcwd(), suffix=&#39;&#39;):
        &#39;&#39;&#39; Download a cutout from the VLASS survey.

        Parameters
        ----------
        ra : float
            Right ascension of the coordinate of interest in degrees.
        dec : float
            Declination of the coordinate of interest in degrees    .
        size : float
            Size of the area of interest in degrees.
        ddir : str
            Location to download the cutout to.
        &#39;&#39;&#39;
        c = SkyCoord(ra, dec, unit=&#39;deg&#39;)
        
        sv = SkyView()

        hdul = sv.get_images(c, self.survey, radius=size * u.deg)
        hdul[0].writeto(os.path.join(ddir, &#39;{:s}_{:.4f}_{:.4f}_{:.3f}.fits&#39;.format(self.survey.replace(&#39; &#39;, &#39;_&#39;), ra, dec, size)))            </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="everystamp.downloaders.FileDownloader"><code class="flex name class">
<span>class <span class="ident">FileDownloader</span></span>
</code></dt>
<dd>
<div class="desc"><p>From <a href="https://medium.com/better-programming/python-progress-bars-with-tqdm-by-example-ce98dbbc9697">https://medium.com/better-programming/python-progress-bars-with-tqdm-by-example-ce98dbbc9697</a>
Copyright 2019 tiptapcode Authors. All Rights Reserved.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
<a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a>
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FileDownloader(object):
    &#39;&#39;&#39; From https://medium.com/better-programming/python-progress-bars-with-tqdm-by-example-ce98dbbc9697
    Copyright 2019 tiptapcode Authors. All Rights Reserved.
    Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
         http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    &#39;&#39;&#39;
    def get_url_filename(self, url):
        &#34;&#34;&#34;
        Discover file name from HTTP URL, If none is discovered derive name from http redirect HTTP content header Location
        :param url: Url link to file to download
        :type url: str
        :return: Base filename
        :rtype: str
        &#34;&#34;&#34;
        try:
            filename = os.path.basename(url)
            basename, ext = os.path.splitext(filename)
            if ext:
                return filename
            header = requests.head(url, allow_redirects=False).headers
            return os.path.basename(header.get(&#39;Location&#39;)) if &#39;Location&#39; in header else filename
        except requests.exceptions.HTTPError as errh:
            print(&#34;Http Error:&#34;, errh)
            raise errh
        except requests.exceptions.ConnectionError as errc:
            print(&#34;Error Connecting:&#34;, errc)
            raise errc
        except requests.exceptions.Timeout as errt:
            print(&#34;Timeout Error:&#34;, errt)
            raise errt
        except requests.exceptions.RequestException as err:
            print(&#34;OOps: Something Else&#34;, err)
            raise err

    def download_file(self, url, filename=None, target_dir=None):
        &#34;&#34;&#34;
        Stream downloads files via HTTP
        :param url: Url link to file to download
        :type url: str
        :param filename: filename overrides filename defined in Url param
        :type filename: str
        :param target_dir: target destination directory to download file to
        :type target_dir: str
        :return: Absolute path to target destination where file has been downloaded to
        :rtype: str
        &#34;&#34;&#34;
        if target_dir and not os.path.isdir(target_dir):
            raise ValueError(&#39;Invalid target_dir={} specified&#39;.format(target_dir))
        local_filename = self.get_url_filename(url) if not filename else filename

        req = requests.get(url, stream=True, verify=True)
        req.raise_for_status()
        try:
            file_size = int(req.headers[&#39;Content-Length&#39;])
        except KeyError:
            if req.headers[&#39;Transfer-Encoding&#39;] == &#39;chunked&#39;:
                file_size = 0
        chunk_size = 1024  # 1 MB
        num_bars = int(file_size / chunk_size)

        base_path = os.path.abspath(os.path.dirname(__file__))
        target_dest_dir = os.path.join(base_path, local_filename) if not target_dir else os.path.join(target_dir, local_filename)
        with open(target_dest_dir, &#39;wb&#39;) as fp:
            for chunk in tqdm.tqdm(req.iter_content(chunk_size=chunk_size), total=num_bars, unit=&#39;KB&#39;, leave=True, file=sys.stdout):
                fp.write(chunk)

        return target_dest_dir</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="everystamp.downloaders.LegacyDownloader" href="#everystamp.downloaders.LegacyDownloader">LegacyDownloader</a></li>
<li><a title="everystamp.downloaders.VLASSDownloader" href="#everystamp.downloaders.VLASSDownloader">VLASSDownloader</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="everystamp.downloaders.FileDownloader.download_file"><code class="name flex">
<span>def <span class="ident">download_file</span></span>(<span>self, url, filename=None, target_dir=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Stream downloads files via HTTP
:param url: Url link to file to download
:type url: str
:param filename: filename overrides filename defined in Url param
:type filename: str
:param target_dir: target destination directory to download file to
:type target_dir: str
:return: Absolute path to target destination where file has been downloaded to
:rtype: str</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def download_file(self, url, filename=None, target_dir=None):
    &#34;&#34;&#34;
    Stream downloads files via HTTP
    :param url: Url link to file to download
    :type url: str
    :param filename: filename overrides filename defined in Url param
    :type filename: str
    :param target_dir: target destination directory to download file to
    :type target_dir: str
    :return: Absolute path to target destination where file has been downloaded to
    :rtype: str
    &#34;&#34;&#34;
    if target_dir and not os.path.isdir(target_dir):
        raise ValueError(&#39;Invalid target_dir={} specified&#39;.format(target_dir))
    local_filename = self.get_url_filename(url) if not filename else filename

    req = requests.get(url, stream=True, verify=True)
    req.raise_for_status()
    try:
        file_size = int(req.headers[&#39;Content-Length&#39;])
    except KeyError:
        if req.headers[&#39;Transfer-Encoding&#39;] == &#39;chunked&#39;:
            file_size = 0
    chunk_size = 1024  # 1 MB
    num_bars = int(file_size / chunk_size)

    base_path = os.path.abspath(os.path.dirname(__file__))
    target_dest_dir = os.path.join(base_path, local_filename) if not target_dir else os.path.join(target_dir, local_filename)
    with open(target_dest_dir, &#39;wb&#39;) as fp:
        for chunk in tqdm.tqdm(req.iter_content(chunk_size=chunk_size), total=num_bars, unit=&#39;KB&#39;, leave=True, file=sys.stdout):
            fp.write(chunk)

    return target_dest_dir</code></pre>
</details>
</dd>
<dt id="everystamp.downloaders.FileDownloader.get_url_filename"><code class="name flex">
<span>def <span class="ident">get_url_filename</span></span>(<span>self, url)</span>
</code></dt>
<dd>
<div class="desc"><p>Discover file name from HTTP URL, If none is discovered derive name from http redirect HTTP content header Location
:param url: Url link to file to download
:type url: str
:return: Base filename
:rtype: str</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_url_filename(self, url):
    &#34;&#34;&#34;
    Discover file name from HTTP URL, If none is discovered derive name from http redirect HTTP content header Location
    :param url: Url link to file to download
    :type url: str
    :return: Base filename
    :rtype: str
    &#34;&#34;&#34;
    try:
        filename = os.path.basename(url)
        basename, ext = os.path.splitext(filename)
        if ext:
            return filename
        header = requests.head(url, allow_redirects=False).headers
        return os.path.basename(header.get(&#39;Location&#39;)) if &#39;Location&#39; in header else filename
    except requests.exceptions.HTTPError as errh:
        print(&#34;Http Error:&#34;, errh)
        raise errh
    except requests.exceptions.ConnectionError as errc:
        print(&#34;Error Connecting:&#34;, errc)
        raise errc
    except requests.exceptions.Timeout as errt:
        print(&#34;Timeout Error:&#34;, errt)
        raise errt
    except requests.exceptions.RequestException as err:
        print(&#34;OOps: Something Else&#34;, err)
        raise err</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="everystamp.downloaders.HiPSDownloader"><code class="flex name class">
<span>class <span class="ident">HiPSDownloader</span></span>
<span>(</span><span>hips, name='')</span>
</code></dt>
<dd>
<div class="desc"><p>Sub-class to download a file from a HiPS image using hips2fits.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HiPSDownloader():
    &#39;&#39;&#39; Sub-class to download a file from a HiPS image using hips2fits.
    &#39;&#39;&#39;
    def __init__(self, hips, name=&#39;&#39;):
        if not hips:
            raise ValueError(&#39;HiPS name cannot be empty.&#39;)
        else:
            self.hips = hips
        if not name:
            self.name = self.hips
            self.logger = logging.getLogger(&#39;EveryStamp:VODownloader&#39;)
        else:
            self.name = name
            self.logger = logging.getLogger(&#39;EveryStamp:HiPSDownloader[{:s}]&#39;.format(self.name))

    def download(self, ra=0.0, dec=0.0, size=0.1, ddir=os.getcwd(), pixsize=1.0, mode=&#39;jpg&#39;):
        &#39;&#39;&#39; Download a cutout from the VLASS survey.

        Parameters
        ----------
        ra : float
            Right ascension of the coordinate of interest in degrees.
        dec : float
            Declination of the coordinate of interest in degrees    .
        size : float
            Size of the area of interest in degrees.
        ddir : str
            Location to download the cutout to.
        pixsize : float
            Pixel scale of the survey in arcsec. Default is 1.0 arcsec per pixel.
        mode : str
            What image format to download. Can be jpg or fits, default is jpg.
        &#39;&#39;&#39;
        imsize = int(size / (pixsize / 3600))
        img = hips2fits.query(hips=self.hips, format=mode, width=imsize, height=imsize, projection=&#39;SIN&#39;, fov=size*u.deg, ra=ra*u.deg, dec=dec*u.deg)
        if mode == &#39;jpg&#39;:
            from PIL import Image
            imdata = Image.fromarray(img)
            imdata.save(os.path.join(ddir, &#39;{:s}_{:.4f}_{:.4f}_{:.3f}.jpeg&#39;.format(self.name, ra, dec, size)))
        elif mode == &#39;fits&#39;:
            img.writeto(os.path.join(ddir, &#39;{:s}_{:.4f}_{:.4f}_{:.3f}.fits&#39;.format(self.name, ra, dec, size)))</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="everystamp.downloaders.HiPSDownloader.download"><code class="name flex">
<span>def <span class="ident">download</span></span>(<span>self, ra=0.0, dec=0.0, size=0.1, ddir='/home/frits/testeverystamp', pixsize=1.0, mode='jpg')</span>
</code></dt>
<dd>
<div class="desc"><p>Download a cutout from the VLASS survey.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ra</code></strong> :&ensp;<code>float</code></dt>
<dd>Right ascension of the coordinate of interest in degrees.</dd>
<dt><strong><code>dec</code></strong> :&ensp;<code>float</code></dt>
<dd>Declination of the coordinate of interest in degrees
.</dd>
<dt><strong><code>size</code></strong> :&ensp;<code>float</code></dt>
<dd>Size of the area of interest in degrees.</dd>
<dt><strong><code>ddir</code></strong> :&ensp;<code>str</code></dt>
<dd>Location to download the cutout to.</dd>
<dt><strong><code>pixsize</code></strong> :&ensp;<code>float</code></dt>
<dd>Pixel scale of the survey in arcsec. Default is 1.0 arcsec per pixel.</dd>
<dt><strong><code>mode</code></strong> :&ensp;<code>str</code></dt>
<dd>What image format to download. Can be jpg or fits, default is jpg.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def download(self, ra=0.0, dec=0.0, size=0.1, ddir=os.getcwd(), pixsize=1.0, mode=&#39;jpg&#39;):
    &#39;&#39;&#39; Download a cutout from the VLASS survey.

    Parameters
    ----------
    ra : float
        Right ascension of the coordinate of interest in degrees.
    dec : float
        Declination of the coordinate of interest in degrees    .
    size : float
        Size of the area of interest in degrees.
    ddir : str
        Location to download the cutout to.
    pixsize : float
        Pixel scale of the survey in arcsec. Default is 1.0 arcsec per pixel.
    mode : str
        What image format to download. Can be jpg or fits, default is jpg.
    &#39;&#39;&#39;
    imsize = int(size / (pixsize / 3600))
    img = hips2fits.query(hips=self.hips, format=mode, width=imsize, height=imsize, projection=&#39;SIN&#39;, fov=size*u.deg, ra=ra*u.deg, dec=dec*u.deg)
    if mode == &#39;jpg&#39;:
        from PIL import Image
        imdata = Image.fromarray(img)
        imdata.save(os.path.join(ddir, &#39;{:s}_{:.4f}_{:.4f}_{:.3f}.jpeg&#39;.format(self.name, ra, dec, size)))
    elif mode == &#39;fits&#39;:
        img.writeto(os.path.join(ddir, &#39;{:s}_{:.4f}_{:.4f}_{:.3f}.fits&#39;.format(self.name, ra, dec, size)))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="everystamp.downloaders.LegacyDownloader"><code class="flex name class">
<span>class <span class="ident">LegacyDownloader</span></span>
</code></dt>
<dd>
<div class="desc"><p>Downloader sub-class for the DESI Legacy Imaging Surveys.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LegacyDownloader(FileDownloader):
    &#39;&#39;&#39; Downloader sub-class for the DESI Legacy Imaging Surveys.
    &#39;&#39;&#39;
    supported_keywords = [&#39;ra&#39;, &#39;dec&#39;, &#39;mode&#39;, &#39;layer&#39;, &#39;pixscale&#39;, &#39;bands&#39;, &#39;size_pix&#39;]
    logger = logging.getLogger(&#39;EveryStamp:LegacyDownloader&#39;)

    def __init__(self):
        self.url = &#39;https://www.legacysurvey.org/viewer/{mode:s}-cutout/?ra={ra:f}&amp;dec={dec:f}&amp;layer={layer:s}&amp;pixscale={pixscale:.3f}&amp;bands={bands:s}&amp;size={size_pix:d}&#39;

    def format_url(self, ra=None, dec=None, size=None, bands=&#39;grz&#39;, mode=&#39;jpeg&#39;, layer=&#39;ls-dr9&#39;, pixscale=0.262, autoscale=False, **kwargs):
        &#39;&#39;&#39;Returns a properly formatted URL that can be used to obtain a cutout from Legacy.
        &#39;&#39;&#39;
        size_pix = int(size * 3600 / pixscale)
        dlpixscale = pixscale
        dlsize_pix = size_pix
        if (size_pix &gt; 3000) and autoscale:
            # Jump to the next available pixel size by scaling from the (approximate) native pixel scale.
            new_pixscale = pixscale
            new_size_pix = int(size * 3600 / new_pixscale)
            while new_size_pix &gt; 3000:
                new_pixscale += 0.262
                new_size_pix = int(size * 3600 / new_pixscale)
            self.logger.warn(&#39;Image size of {:.2f} deg with pixel scale {:.3f} exceeds server limit of 3000 pixels! Automatically adjusting pixel scale to {:.3f} giving {:d} pixels.&#39;.format(size, pixscale, new_pixscale, new_size_pix), Warning, stacklevel=2)
            dlpixscale = new_pixscale
            dlsize_pix = new_size_pix
        elif size_pix &gt; 3000:
            self.logger.warn(&#39;Image size of {:.2f} deg with pixel scale {:.3f} exceeds server limit of 3000 pixels! Image will be truncated! Use --legacy_autoscale or pass autoscale=True to automatically switch pixel scales.&#39;.format(size, pixscale), Warning, stacklevel=2)
        return self.url.format(ra=ra, dec=dec, size_pix=dlsize_pix, bands=bands, mode=mode, layer=layer, pixscale=dlpixscale)

    def download(self, **kwargs):
        furl = self.format_url(**kwargs)
        self.logger.info(&#39;Downloading cutout from %s&#39;, furl)
        if not kwargs[&#39;ddir&#39;]:
            self.logger.info(&#39;Download directory not specified, downloading to %s instead&#39;, os.getcwd())
            ddir = os.getcwd()
        else:
            ddir = kwargs[&#39;ddir&#39;]
        fname = &#39;legacystamps_{ra:f}_{dec:f}_{layer:s}.{mode:s}&#39;.format(ra=kwargs[&#39;ra&#39;], dec=kwargs[&#39;dec&#39;], layer=kwargs[&#39;layer&#39;], mode=kwargs[&#39;mode&#39;])
        self.download_file(furl, filename=fname, target_dir=ddir)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="everystamp.downloaders.FileDownloader" href="#everystamp.downloaders.FileDownloader">FileDownloader</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="everystamp.downloaders.LegacyDownloader.logger"><code class="name">var <span class="ident">logger</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="everystamp.downloaders.LegacyDownloader.supported_keywords"><code class="name">var <span class="ident">supported_keywords</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="everystamp.downloaders.LegacyDownloader.download"><code class="name flex">
<span>def <span class="ident">download</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def download(self, **kwargs):
    furl = self.format_url(**kwargs)
    self.logger.info(&#39;Downloading cutout from %s&#39;, furl)
    if not kwargs[&#39;ddir&#39;]:
        self.logger.info(&#39;Download directory not specified, downloading to %s instead&#39;, os.getcwd())
        ddir = os.getcwd()
    else:
        ddir = kwargs[&#39;ddir&#39;]
    fname = &#39;legacystamps_{ra:f}_{dec:f}_{layer:s}.{mode:s}&#39;.format(ra=kwargs[&#39;ra&#39;], dec=kwargs[&#39;dec&#39;], layer=kwargs[&#39;layer&#39;], mode=kwargs[&#39;mode&#39;])
    self.download_file(furl, filename=fname, target_dir=ddir)</code></pre>
</details>
</dd>
<dt id="everystamp.downloaders.LegacyDownloader.format_url"><code class="name flex">
<span>def <span class="ident">format_url</span></span>(<span>self, ra=None, dec=None, size=None, bands='grz', mode='jpeg', layer='ls-dr9', pixscale=0.262, autoscale=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a properly formatted URL that can be used to obtain a cutout from Legacy.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def format_url(self, ra=None, dec=None, size=None, bands=&#39;grz&#39;, mode=&#39;jpeg&#39;, layer=&#39;ls-dr9&#39;, pixscale=0.262, autoscale=False, **kwargs):
    &#39;&#39;&#39;Returns a properly formatted URL that can be used to obtain a cutout from Legacy.
    &#39;&#39;&#39;
    size_pix = int(size * 3600 / pixscale)
    dlpixscale = pixscale
    dlsize_pix = size_pix
    if (size_pix &gt; 3000) and autoscale:
        # Jump to the next available pixel size by scaling from the (approximate) native pixel scale.
        new_pixscale = pixscale
        new_size_pix = int(size * 3600 / new_pixscale)
        while new_size_pix &gt; 3000:
            new_pixscale += 0.262
            new_size_pix = int(size * 3600 / new_pixscale)
        self.logger.warn(&#39;Image size of {:.2f} deg with pixel scale {:.3f} exceeds server limit of 3000 pixels! Automatically adjusting pixel scale to {:.3f} giving {:d} pixels.&#39;.format(size, pixscale, new_pixscale, new_size_pix), Warning, stacklevel=2)
        dlpixscale = new_pixscale
        dlsize_pix = new_size_pix
    elif size_pix &gt; 3000:
        self.logger.warn(&#39;Image size of {:.2f} deg with pixel scale {:.3f} exceeds server limit of 3000 pixels! Image will be truncated! Use --legacy_autoscale or pass autoscale=True to automatically switch pixel scales.&#39;.format(size, pixscale), Warning, stacklevel=2)
    return self.url.format(ra=ra, dec=dec, size_pix=dlsize_pix, bands=bands, mode=mode, layer=layer, pixscale=dlpixscale)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="everystamp.downloaders.FileDownloader" href="#everystamp.downloaders.FileDownloader">FileDownloader</a></b></code>:
<ul class="hlist">
<li><code><a title="everystamp.downloaders.FileDownloader.download_file" href="#everystamp.downloaders.FileDownloader.download_file">download_file</a></code></li>
<li><code><a title="everystamp.downloaders.FileDownloader.get_url_filename" href="#everystamp.downloaders.FileDownloader.get_url_filename">get_url_filename</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="everystamp.downloaders.PanSTARRSDownloader"><code class="flex name class">
<span>class <span class="ident">PanSTARRSDownloader</span></span>
</code></dt>
<dd>
<div class="desc"><p>Downloader sub-class for the VLASS survey.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PanSTARRSDownloader():
    &#39;&#39;&#39; Downloader sub-class for the VLASS survey.
    &#39;&#39;&#39;
    from panstamps.downloader import downloader as psdownloader

    def __init__(self):
        self.logger = logging.getLogger(&#39;EveryStamp:Pan-STARRSDownloader&#39;)

    def download(self, ra, dec, size, mode=&#39;jpeg&#39;, ddir=&#39;&#39;, bands=&#39;gri&#39;):
        if mode == &#39;jpeg&#39;:
            get_jpeg = True
            get_fits = False
        elif mode == &#39;fits&#39;:
            get_jpeg = False
            get_fits = True
        elif mode == &#39;both&#39;:
            get_jpeg = True
            get_fits = True
        arcsecsize = size * 3600
        self.logger.info(&#39;Downloading cutout from PANSTARRS&#39;)
        d = self.psdownloader(ra=ra, dec=dec, downloadDirectory=ddir or os.getcwd(), fits=get_fits, jpeg=get_jpeg, color=True, singleFilters=True, filterSet=bands, imageType=&#39;stack&#39;, arcsecSize=arcsecsize, log=self.logger)
        fitspath, jpegpath, colorpaths = d.get()
        # Rename the output slightly so the user can find it easier.
        for colorpath in colorpaths:
            os.rename(colorpath, os.path.join(os.path.dirname(colorpath),  &#39;panstamps_&#39; + os.path.basename(colorpath)))</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="everystamp.downloaders.PanSTARRSDownloader.psdownloader"><code class="name">var <span class="ident">psdownloader</span></code></dt>
<dd>
<div class="desc"><p><em>Tools to download the panstarrs image stamps from STScI PanSTARRS image server</em></p>
<p><strong>Key Arguments</strong></p>
<ul>
<li><code>log</code> &ndash; logger</li>
<li><code>settings</code> &ndash; the settings dictionary</li>
<li><code>downloadDirectory</code> &ndash; the path to where you want to download the images to. Downlaods to path command is run from by default.</li>
<li><code>fits</code> &ndash; download the fits files? Default <em>True</em></li>
<li><code>jpeg</code> &ndash; download the jpeg files? Default <em>False</em></li>
<li><code>arcsecSize</code> &ndash; the size of the image stamps to download (1 arcsec == 4 pixels). Default <em>60</em></li>
<li><code>filterSet</code> &ndash; the filter set used to create color and/or download as individual stamps. Default <em>gri</em></li>
<li><code>color</code> &ndash; download the color jpeg? Default <em>True</em></li>
<li><code>singleFilters</code> &ndash; download the single filter stmaps? Default <em>False</em></li>
<li>
<p><code>ra</code> &ndash; ra in decimal degrees.</p>
<ul>
<li><code>dec</code> &ndash; dec in decimal degrees.</li>
<li><code>imageType</code> &ndash; warp or stacked images? Default <em>stack</em></li>
<li><code>mjdStart</code> &ndash; the start of a time-window within which the images required are taken. Default <em>False</em> (everything)</li>
<li><code>mjdEnd</code> &ndash; the end of a time-window within which the images required are taken. Default <em>False</em> (everything)</li>
</ul>
</li>
</ul>
<p><strong>Usage</strong></p>
<p>The following will return 3 lists of paths to local fits, jpeg and color-jpeg files:</p>
<pre><code class="language-python">from panstamps.downloader import downloader
fitsPaths, jpegPaths, colorPath = downloader(
    log=log,
    settings=False,
    fits=False,
    jpeg=True,
    arcsecSize=600,
    filterSet='gri',
    color=True,
    singleFilters=True,
    ra=&quot;70.60271&quot;,
    dec=&quot;-21.72433&quot;,
    imageType=&quot;stack&quot;,
    mjdStart=False,
    mjdEnd=False,
    window=False
).get() 
</code></pre></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="everystamp.downloaders.PanSTARRSDownloader.download"><code class="name flex">
<span>def <span class="ident">download</span></span>(<span>self, ra, dec, size, mode='jpeg', ddir='', bands='gri')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def download(self, ra, dec, size, mode=&#39;jpeg&#39;, ddir=&#39;&#39;, bands=&#39;gri&#39;):
    if mode == &#39;jpeg&#39;:
        get_jpeg = True
        get_fits = False
    elif mode == &#39;fits&#39;:
        get_jpeg = False
        get_fits = True
    elif mode == &#39;both&#39;:
        get_jpeg = True
        get_fits = True
    arcsecsize = size * 3600
    self.logger.info(&#39;Downloading cutout from PANSTARRS&#39;)
    d = self.psdownloader(ra=ra, dec=dec, downloadDirectory=ddir or os.getcwd(), fits=get_fits, jpeg=get_jpeg, color=True, singleFilters=True, filterSet=bands, imageType=&#39;stack&#39;, arcsecSize=arcsecsize, log=self.logger)
    fitspath, jpegpath, colorpaths = d.get()
    # Rename the output slightly so the user can find it easier.
    for colorpath in colorpaths:
        os.rename(colorpath, os.path.join(os.path.dirname(colorpath),  &#39;panstamps_&#39; + os.path.basename(colorpath)))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="everystamp.downloaders.SkyViewDownloader"><code class="flex name class">
<span>class <span class="ident">SkyViewDownloader</span></span>
<span>(</span><span>survey)</span>
</code></dt>
<dd>
<div class="desc"><p>Downloader sub-class for surveys offeret through a VO.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SkyViewDownloader():
    &#39;&#39;&#39; Downloader sub-class for surveys offeret through a VO.
    &#39;&#39;&#39;
    def __init__(self, survey):
        if not survey:
            raise ValueError(&#39;SkyView survey cannot be empty.&#39;)
        else:
            self.survey = survey
            self.logger = logging.getLogger(&#39;EveryStamp:SkyViewDownloader[{:s}]&#39;.format(self.survey))

    def download(self, ra=0.0, dec=0.0, size=0.1, ddir=os.getcwd(), suffix=&#39;&#39;):
        &#39;&#39;&#39; Download a cutout from the VLASS survey.

        Parameters
        ----------
        ra : float
            Right ascension of the coordinate of interest in degrees.
        dec : float
            Declination of the coordinate of interest in degrees    .
        size : float
            Size of the area of interest in degrees.
        ddir : str
            Location to download the cutout to.
        &#39;&#39;&#39;
        c = SkyCoord(ra, dec, unit=&#39;deg&#39;)
        
        sv = SkyView()

        hdul = sv.get_images(c, self.survey, radius=size * u.deg)
        hdul[0].writeto(os.path.join(ddir, &#39;{:s}_{:.4f}_{:.4f}_{:.3f}.fits&#39;.format(self.survey.replace(&#39; &#39;, &#39;_&#39;), ra, dec, size)))            </code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="everystamp.downloaders.SkyViewDownloader.download"><code class="name flex">
<span>def <span class="ident">download</span></span>(<span>self, ra=0.0, dec=0.0, size=0.1, ddir='/home/frits/testeverystamp', suffix='')</span>
</code></dt>
<dd>
<div class="desc"><p>Download a cutout from the VLASS survey.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ra</code></strong> :&ensp;<code>float</code></dt>
<dd>Right ascension of the coordinate of interest in degrees.</dd>
<dt><strong><code>dec</code></strong> :&ensp;<code>float</code></dt>
<dd>Declination of the coordinate of interest in degrees
.</dd>
<dt><strong><code>size</code></strong> :&ensp;<code>float</code></dt>
<dd>Size of the area of interest in degrees.</dd>
<dt><strong><code>ddir</code></strong> :&ensp;<code>str</code></dt>
<dd>Location to download the cutout to.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def download(self, ra=0.0, dec=0.0, size=0.1, ddir=os.getcwd(), suffix=&#39;&#39;):
    &#39;&#39;&#39; Download a cutout from the VLASS survey.

    Parameters
    ----------
    ra : float
        Right ascension of the coordinate of interest in degrees.
    dec : float
        Declination of the coordinate of interest in degrees    .
    size : float
        Size of the area of interest in degrees.
    ddir : str
        Location to download the cutout to.
    &#39;&#39;&#39;
    c = SkyCoord(ra, dec, unit=&#39;deg&#39;)
    
    sv = SkyView()

    hdul = sv.get_images(c, self.survey, radius=size * u.deg)
    hdul[0].writeto(os.path.join(ddir, &#39;{:s}_{:.4f}_{:.4f}_{:.3f}.fits&#39;.format(self.survey.replace(&#39; &#39;, &#39;_&#39;), ra, dec, size)))            </code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="everystamp.downloaders.VLASSDownloader"><code class="flex name class">
<span>class <span class="ident">VLASSDownloader</span></span>
</code></dt>
<dd>
<div class="desc"><p>Downloader sub-class for the VLASS survey.</p>
<p>Based on the original code by Anna Ho (<a href="https://github.com/annayqho/Query_VLASS">https://github.com/annayqho/Query_VLASS</a>) and edits by R. Timmerman.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VLASSDownloader(FileDownloader):
    &#39;&#39;&#39; Downloader sub-class for the VLASS survey.

    Based on the original code by Anna Ho (https://github.com/annayqho/Query_VLASS) and edits by R. Timmerman.
    &#39;&#39;&#39;
    def __init__(self):
        self.summary_url = &#39;https://archive-new.nrao.edu/vlass/VLASS_dyn_summary.php&#39;
        self.logger = logging.getLogger(&#39;EveryStamp:VLASSDownloader&#39;)
        self.pixel_scale = 1.0  # arcsec / pixel

    def get_tiles(self, summary_file=&#39;VLASS_dyn_summary.php&#39;):
        &#39;&#39;&#39;
        Read tiles from tile catalog. If file missing, try wget https://archive-new.nrao.edu/vlass/VLASS_dyn_summary.php

        Parameters
        ----------
        summary_file : str
            Location where the VLASS summary file is located.

        Returns
        -------
        tab : astropy Table
            Table containing tile information.
        &#39;&#39;&#39;
        if not os.path.isfile(summary_file):
            self.logger.warn(f&#39;Could not find VLASS summary file {summary_file}!&#39;)
            self.logger.info(&#39;Attempting to download VLASS summary file&#39;)
            subprocess.run([&#39;wget&#39;, &#39;https://archive-new.nrao.edu/vlass/VLASS_dyn_summary.php&#39;, &#39;-O&#39;, summary_file])
        
        # Put it in a more managable format by replacing consecutive white space with commas.
        # Assumes no more than 1 space in valid entries.
        subprocess.run([&#39;sed&#39;, &#39;-i&#39;, &#39;-e&#39;, r&#39;s/ \{2,\}/,/g&#39;, summary_file], check=True)

        tab = Table.read(summary_file, data_start=3, format=&#39;ascii.csv&#39;)
        tab.rename_column(&#39;Observing&#39;, &#39;Epoch&#39;)
        tab.rename_column(&#39;Observation&#39;, &#39;Date&#39;)
        return tab

    def search_tiles(self, tiles, c):
        &#39;&#39;&#39; Search the tile catalog for tiles containing the input coordinate

        Parameters
        ----------
        tiles : astropy Table
            Tile catalogue as obtained from get_tiles()
        c : SkyCoord
            Location to check for coverage in one of the observed tiles.

        Returns
        -------
        tile name : str
            Best matching tile.
        observing epoch : str
            Epoch the best matching tile was observed in.
        observing date : str
            Date the best matching tile was observed at.
        &#39;&#39;&#39;
        ra_h = c.ra.hour
        dec_d = c.dec.deg

        has_dec = np.logical_and(dec_d &gt;= tiles[&#39;Dec min&#39;], dec_d &lt; tiles[&#39;Dec max&#39;])
        has_ra = np.logical_and(ra_h &gt;= tiles[&#39;RA min&#39;], ra_h &lt; tiles[&#39;RA max&#39;])
        in_tile = np.logical_and(has_ra, has_dec)
        name = tiles[&#39;Tile&#39;][in_tile]
        epoch = tiles[&#39;Epoch&#39;][in_tile]
        date = tiles[&#39;Date&#39;][in_tile]    
        if len(name) == 0:
            raise IndexError(&#34;Zero VLASS tiles available for the given coordinate&#34;)
        c_grid = SkyCoord(7.5*(tiles[&#39;RA min&#39;][in_tile] + tiles[&#39;RA max&#39;][in_tile]), 0.5 * (tiles[&#39;Dec min&#39;][in_tile] + tiles[&#39;Dec max&#39;][in_tile]), unit=&#39;deg&#39;, frame=&#39;icrs&#39;)
        dist = c_grid.separation(c)
        best_idx = np.argmin(dist)
        return name[best_idx], epoch[best_idx], date[best_idx]

    def get_subtiles(self, tilename, epoch, consider_QA_rejected):
        &#39;&#39;&#39; For a given tile name, get the subtile filenames in the VLASS directory

        Parse those filenames and return a list of subtile RA and Dec.
        RA and Dec returned as a SkyCoord object

        Parameters
        ----------
        tilename : str
            Name of the tile to extract a subtile from.
        epoch : str
            The epoch the tile was observed in.
        consider_QA_rejected : bool
            Also consider tiles that did not pass the quality assurance checks.

        Returns
        -------
        fname : str
            Name of the subtile.
        c : astropy SkyCoord
            Coordinate of the subtile.
        &#39;&#39;&#39;

        # Obtain the HTML for the given tile
        if &#39;2.1&#39; in epoch:
            self.logger.info(f&#39;Downloading from https://archive-new.nrao.edu/vlass/quicklook/{epoch}/{tilename}&#39;)
            urlpath = urlopen(f&#34;https://archive-new.nrao.edu/vlass/quicklook/{epoch}/{tilename}&#34;)
        else:
            self.logger.info(f&#39;Downloading from https://archive-new.nrao.edu/vlass/quicklook/{epoch}v2/{tilename}&#39;)
            urlpath = urlopen(f&#34;https://archive-new.nrao.edu/vlass/quicklook/{epoch}v2/{tilename}&#34;)
        string = urlpath.read().decode(&#39;utf-8&#39;).split(&#34;\n&#34;)

        if consider_QA_rejected:
            # Obtain the HTML for the QA Rejected
            urlpath_rejected = urlopen(f&#34;https://archive-new.nrao.edu/vlass/quicklook/{epoch}v2/QA_REJECTED&#34;)
            string += urlpath_rejected.read().decode(&#39;utf-8&#39;).split(&#34;\n&#34;)

        # Select only the subtile parts
        vals = np.array([val.strip() for val in string if (&#34;href&#34; in val.strip()) and (tilename in val.strip())])

        # Select the coordinate part. You want the &#39;VLASS1.1.ql.T25t12.J150000+603000.10.2048.v1/&#39; bit
        fname = np.array([val.split(&#34;\&#34;&#34;)[7] for val in vals])

        # Split out the actual coordinate string
        pos_raw = np.array([val.split(&#34;.&#34;)[4] for val in fname])

        if &#39;-&#39; in pos_raw[0]:
            # dec &lt; 0
            ra_raw = np.array([val.split(&#34;-&#34;)[0] for val in pos_raw])
            dec_raw = np.array([val.split(&#34;-&#34;)[1] for val in pos_raw])
        else:
            # dec &gt; 0
            ra_raw = np.array([val.split(&#34;+&#34;)[0] for val in pos_raw])
            dec_raw = np.array([val.split(&#34;+&#34;)[1] for val in pos_raw])
        ra = []
        dec = []
        for ii,val in enumerate(ra_raw):
            if val[1:3] == &#39;24&#39;:
                rah = &#39;00&#39;
            else:
                rah = val[1:3]
            ra.append(f&#34;{rah}h{val[3:5]}m{val[5:]}s&#34;)
            dec.append(f&#34;{dec_raw[ii][:2]}d{dec_raw[ii][2:4]}m{dec_raw[ii][4:]}s&#34;)
        ra = np.array(ra)
        dec = np.array(dec)
        c = SkyCoord(ra, dec, frame=&#39;icrs&#39;)#.directional_offset_by(45*u.deg, 0.75*u.deg)
        return fname, c

    def get_cutout(self, imname, c, crop_scale):
        &#39;&#39;&#39; Get a smaller cutout from the subtile.
        
        Parameters
        ----------
        imname : str
            Name of the image to make a cutout from.
        c : astropy SkyCoord
            Coordinate around which to make a cutout.
        crop_scale : int
            Size of the cutout in pixels.

        Returns
        -------
        output_fits : str
            Name of the output FITS file.
        &#39;&#39;&#39;
        # Define output name
        output_fits = imname.rstrip(&#39;.fits&#39;) + &#39;_poststamp.fits&#39;
        
        # Get header info
        hdu_list = fits.open(imname)
        header = hdu_list[0].header
        data = hdu_list[0].data[0,0,:,:]
        
        # Obtain header and drop useless axes
        wcs = WCS(header)
        wcs = wcs.dropaxis(2).dropaxis(2)
        
        pixel_coords = skycoord_to_pixel(SkyCoord(c.ra.deg, c.dec.deg, unit=&#39;deg&#39;, frame=&#39;icrs&#39;), wcs)
        
        if pixel_coords[0] &lt; 0  or pixel_coords[1] &lt; 0 or pixel_coords[0] &gt; data.shape[0]  or pixel_coords[1] &gt; data.shape[1]:
            subprocess.call(f&#39;rm -f {imname}&#39;, shell=True)
            raise Exception(&#39;Requested coordinate not within the available subtiles. Consider running with consider_QA_rejected=True to also search additional subtiles which failed initial QA checks&#39;)
            
        # Produce a cutout
        cutout = Cutout2D(data, c, (crop_scale, crop_scale), wcs=wcs)
            
        # Update the HDU
        hdu_list[0].data = cutout.data
        new_header = cutout.wcs.to_header()
        hdu_list[0].header.update(new_header)
        hdu_list[0].header.set(&#39;NAXIS&#39;, 4)
        hdu_list[0].header.insert(&#39;NAXIS2&#39;, (&#39;NAXIS3&#39;, 1), after=True)
        hdu_list[0].header.insert(&#39;NAXIS3&#39;, (&#39;NAXIS4&#39;, 1), after=True)
        hdu_list[0].header.remove(&#39;WCSAXES&#39;, ignore_missing=True)
        hdu_list[0].header.remove(&#39;MJDREF&#39;, ignore_missing=True)
        hdu_list[0].header.remove(&#39;MJD-OBS&#39;, ignore_missing=True)
        
        # Write the new fits
        hdu_list.writeto(output_fits, overwrite=True)
        
        # Cleanup
        subprocess.call(f&#34;rm -f {imname}&#34;, shell=True)

        return output_fits

    def search_vlass(self, c, crop=False, crop_scale=256, consider_QA_rejected=False, ddir=os.getcwd()):
        &#34;&#34;&#34; 
        Searches the VLASS catalog for a source

        Parameters
        ----------
        c : astropy SkyCoord
            Coordinate to search for in tiles.
        crop : bool
            Make a cropped cutout of the area of interest.
        crop_scale : int
            Crop the cutout to this amount of pixels centred around c.
        consider_QA_rejected : bool
            Also consider tiles that failed the Quality Assurance checks.
        ddir : str
            Location to download the cutout to.

        Returns
        -------
        imname : str
            Name of the output image.
        &#34;&#34;&#34;
        # Find the VLASS tile
        tiles = self.get_tiles()
        tilename, epoch, obsdate = self.search_tiles(tiles, c)

        subtiles, c_tiles = self.get_subtiles(tilename, epoch, consider_QA_rejected)
        dist = c.separation(c_tiles)
        subtile = subtiles[np.argmin(dist)]

        imname = f&#34;{subtile[:-1]}.I.iter1.image.pbcor.tt0.subim.fits&#34;
        if len(glob.glob(imname)) == 0:
            if &#39;2.1&#39; in epoch:
                url_get = f&#34;https://archive-new.nrao.edu/vlass/quicklook/{epoch}/{tilename}/{subtile}&#34;
            else:
                url_get = f&#34;https://archive-new.nrao.edu/vlass/quicklook/{epoch}v2/{tilename}/{subtile}&#34;
            fname = f&#34;{url_get}{imname}&#34;
            self.logger.info(&#39;Downloading to &#39; + ddir)
            self.download_file(fname, target_dir=ddir)
            if consider_QA_rejected:
                if &#39;2.1&#39; in epoch:
                    url_get = f&#34;https://archive-new.nrao.edu/vlass/quicklook/{epoch}/QA_REJECTED/{subtile}&#34;
                else:
                    url_get = f&#34;https://archive-new.nrao.edu/vlass/quicklook/{epoch}v2/QA_REJECTED/{subtile}&#34;
                fname = f&#34;{url_get}{imname}&#34;
                self.download_file(fname, target_dir=ddir)
        if crop:    
            out = self.get_cutout(os.path.join(ddir, imname), c, crop_scale=crop_scale)
            return out
        else:
            return imname

    def download(self, ra=0.0, dec=0.0, size=0.1, ms=&#39;&#39;, crop=True, consider_QA_rejected=False, ddir=os.getcwd()):
        &#39;&#39;&#39; Download a cutout from the VLASS survey.

        Parameters
        ----------
        ra : float
            Right ascension of the coordinate of interest.
        dec : float
            Declination of the coordinate of interest.
        size : float
            Size of the area of interest in degrees.
        ms : str
            Path to a Measurement Set to take coordinates from instead of using ra and dec.
        crop : bool
            Crop the image to the area of interest.
        consider_QA_rejected : bool
            Also consider tiles that failed the Quality Assurance checks.
        ddir : str
            Location to download the cutout to.
        &#39;&#39;&#39;
        if ms:
            with ct.table(ms.rstrip(&#39;/&#39;) + &#39;::FIELD&#39;) as field:
                direction = field.getcol(&#39;PHASE_DIR&#39;).squeeze()
            ra = (direction[0] % (2 * np.pi)) / np.pi * 180
            dec = direction[1] / np.pi * 180

        c = SkyCoord(ra, dec, unit=&#39;deg&#39;)
        
        crop_scale = size * 3600 / self.pixel_scale
        self.logger.info(&#39;Downloading cutout from VLASS&#39;)
        self.search_vlass(c, crop=crop, crop_scale=crop_scale, consider_QA_rejected=consider_QA_rejected, ddir=ddir)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="everystamp.downloaders.FileDownloader" href="#everystamp.downloaders.FileDownloader">FileDownloader</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="everystamp.downloaders.VLASSDownloader.download"><code class="name flex">
<span>def <span class="ident">download</span></span>(<span>self, ra=0.0, dec=0.0, size=0.1, ms='', crop=True, consider_QA_rejected=False, ddir='/home/frits/testeverystamp')</span>
</code></dt>
<dd>
<div class="desc"><p>Download a cutout from the VLASS survey.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ra</code></strong> :&ensp;<code>float</code></dt>
<dd>Right ascension of the coordinate of interest.</dd>
<dt><strong><code>dec</code></strong> :&ensp;<code>float</code></dt>
<dd>Declination of the coordinate of interest.</dd>
<dt><strong><code>size</code></strong> :&ensp;<code>float</code></dt>
<dd>Size of the area of interest in degrees.</dd>
<dt><strong><code>ms</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to a Measurement Set to take coordinates from instead of using ra and dec.</dd>
<dt><strong><code>crop</code></strong> :&ensp;<code>bool</code></dt>
<dd>Crop the image to the area of interest.</dd>
<dt><strong><code>consider_QA_rejected</code></strong> :&ensp;<code>bool</code></dt>
<dd>Also consider tiles that failed the Quality Assurance checks.</dd>
<dt><strong><code>ddir</code></strong> :&ensp;<code>str</code></dt>
<dd>Location to download the cutout to.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def download(self, ra=0.0, dec=0.0, size=0.1, ms=&#39;&#39;, crop=True, consider_QA_rejected=False, ddir=os.getcwd()):
    &#39;&#39;&#39; Download a cutout from the VLASS survey.

    Parameters
    ----------
    ra : float
        Right ascension of the coordinate of interest.
    dec : float
        Declination of the coordinate of interest.
    size : float
        Size of the area of interest in degrees.
    ms : str
        Path to a Measurement Set to take coordinates from instead of using ra and dec.
    crop : bool
        Crop the image to the area of interest.
    consider_QA_rejected : bool
        Also consider tiles that failed the Quality Assurance checks.
    ddir : str
        Location to download the cutout to.
    &#39;&#39;&#39;
    if ms:
        with ct.table(ms.rstrip(&#39;/&#39;) + &#39;::FIELD&#39;) as field:
            direction = field.getcol(&#39;PHASE_DIR&#39;).squeeze()
        ra = (direction[0] % (2 * np.pi)) / np.pi * 180
        dec = direction[1] / np.pi * 180

    c = SkyCoord(ra, dec, unit=&#39;deg&#39;)
    
    crop_scale = size * 3600 / self.pixel_scale
    self.logger.info(&#39;Downloading cutout from VLASS&#39;)
    self.search_vlass(c, crop=crop, crop_scale=crop_scale, consider_QA_rejected=consider_QA_rejected, ddir=ddir)</code></pre>
</details>
</dd>
<dt id="everystamp.downloaders.VLASSDownloader.get_cutout"><code class="name flex">
<span>def <span class="ident">get_cutout</span></span>(<span>self, imname, c, crop_scale)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a smaller cutout from the subtile.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>imname</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the image to make a cutout from.</dd>
<dt><strong><code>c</code></strong> :&ensp;<code>astropy SkyCoord</code></dt>
<dd>Coordinate around which to make a cutout.</dd>
<dt><strong><code>crop_scale</code></strong> :&ensp;<code>int</code></dt>
<dd>Size of the cutout in pixels.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>output_fits</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the output FITS file.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cutout(self, imname, c, crop_scale):
    &#39;&#39;&#39; Get a smaller cutout from the subtile.
    
    Parameters
    ----------
    imname : str
        Name of the image to make a cutout from.
    c : astropy SkyCoord
        Coordinate around which to make a cutout.
    crop_scale : int
        Size of the cutout in pixels.

    Returns
    -------
    output_fits : str
        Name of the output FITS file.
    &#39;&#39;&#39;
    # Define output name
    output_fits = imname.rstrip(&#39;.fits&#39;) + &#39;_poststamp.fits&#39;
    
    # Get header info
    hdu_list = fits.open(imname)
    header = hdu_list[0].header
    data = hdu_list[0].data[0,0,:,:]
    
    # Obtain header and drop useless axes
    wcs = WCS(header)
    wcs = wcs.dropaxis(2).dropaxis(2)
    
    pixel_coords = skycoord_to_pixel(SkyCoord(c.ra.deg, c.dec.deg, unit=&#39;deg&#39;, frame=&#39;icrs&#39;), wcs)
    
    if pixel_coords[0] &lt; 0  or pixel_coords[1] &lt; 0 or pixel_coords[0] &gt; data.shape[0]  or pixel_coords[1] &gt; data.shape[1]:
        subprocess.call(f&#39;rm -f {imname}&#39;, shell=True)
        raise Exception(&#39;Requested coordinate not within the available subtiles. Consider running with consider_QA_rejected=True to also search additional subtiles which failed initial QA checks&#39;)
        
    # Produce a cutout
    cutout = Cutout2D(data, c, (crop_scale, crop_scale), wcs=wcs)
        
    # Update the HDU
    hdu_list[0].data = cutout.data
    new_header = cutout.wcs.to_header()
    hdu_list[0].header.update(new_header)
    hdu_list[0].header.set(&#39;NAXIS&#39;, 4)
    hdu_list[0].header.insert(&#39;NAXIS2&#39;, (&#39;NAXIS3&#39;, 1), after=True)
    hdu_list[0].header.insert(&#39;NAXIS3&#39;, (&#39;NAXIS4&#39;, 1), after=True)
    hdu_list[0].header.remove(&#39;WCSAXES&#39;, ignore_missing=True)
    hdu_list[0].header.remove(&#39;MJDREF&#39;, ignore_missing=True)
    hdu_list[0].header.remove(&#39;MJD-OBS&#39;, ignore_missing=True)
    
    # Write the new fits
    hdu_list.writeto(output_fits, overwrite=True)
    
    # Cleanup
    subprocess.call(f&#34;rm -f {imname}&#34;, shell=True)

    return output_fits</code></pre>
</details>
</dd>
<dt id="everystamp.downloaders.VLASSDownloader.get_subtiles"><code class="name flex">
<span>def <span class="ident">get_subtiles</span></span>(<span>self, tilename, epoch, consider_QA_rejected)</span>
</code></dt>
<dd>
<div class="desc"><p>For a given tile name, get the subtile filenames in the VLASS directory</p>
<p>Parse those filenames and return a list of subtile RA and Dec.
RA and Dec returned as a SkyCoord object</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tilename</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the tile to extract a subtile from.</dd>
<dt><strong><code>epoch</code></strong> :&ensp;<code>str</code></dt>
<dd>The epoch the tile was observed in.</dd>
<dt><strong><code>consider_QA_rejected</code></strong> :&ensp;<code>bool</code></dt>
<dd>Also consider tiles that did not pass the quality assurance checks.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fname</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the subtile.</dd>
<dt><strong><code>c</code></strong> :&ensp;<code>astropy SkyCoord</code></dt>
<dd>Coordinate of the subtile.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_subtiles(self, tilename, epoch, consider_QA_rejected):
    &#39;&#39;&#39; For a given tile name, get the subtile filenames in the VLASS directory

    Parse those filenames and return a list of subtile RA and Dec.
    RA and Dec returned as a SkyCoord object

    Parameters
    ----------
    tilename : str
        Name of the tile to extract a subtile from.
    epoch : str
        The epoch the tile was observed in.
    consider_QA_rejected : bool
        Also consider tiles that did not pass the quality assurance checks.

    Returns
    -------
    fname : str
        Name of the subtile.
    c : astropy SkyCoord
        Coordinate of the subtile.
    &#39;&#39;&#39;

    # Obtain the HTML for the given tile
    if &#39;2.1&#39; in epoch:
        self.logger.info(f&#39;Downloading from https://archive-new.nrao.edu/vlass/quicklook/{epoch}/{tilename}&#39;)
        urlpath = urlopen(f&#34;https://archive-new.nrao.edu/vlass/quicklook/{epoch}/{tilename}&#34;)
    else:
        self.logger.info(f&#39;Downloading from https://archive-new.nrao.edu/vlass/quicklook/{epoch}v2/{tilename}&#39;)
        urlpath = urlopen(f&#34;https://archive-new.nrao.edu/vlass/quicklook/{epoch}v2/{tilename}&#34;)
    string = urlpath.read().decode(&#39;utf-8&#39;).split(&#34;\n&#34;)

    if consider_QA_rejected:
        # Obtain the HTML for the QA Rejected
        urlpath_rejected = urlopen(f&#34;https://archive-new.nrao.edu/vlass/quicklook/{epoch}v2/QA_REJECTED&#34;)
        string += urlpath_rejected.read().decode(&#39;utf-8&#39;).split(&#34;\n&#34;)

    # Select only the subtile parts
    vals = np.array([val.strip() for val in string if (&#34;href&#34; in val.strip()) and (tilename in val.strip())])

    # Select the coordinate part. You want the &#39;VLASS1.1.ql.T25t12.J150000+603000.10.2048.v1/&#39; bit
    fname = np.array([val.split(&#34;\&#34;&#34;)[7] for val in vals])

    # Split out the actual coordinate string
    pos_raw = np.array([val.split(&#34;.&#34;)[4] for val in fname])

    if &#39;-&#39; in pos_raw[0]:
        # dec &lt; 0
        ra_raw = np.array([val.split(&#34;-&#34;)[0] for val in pos_raw])
        dec_raw = np.array([val.split(&#34;-&#34;)[1] for val in pos_raw])
    else:
        # dec &gt; 0
        ra_raw = np.array([val.split(&#34;+&#34;)[0] for val in pos_raw])
        dec_raw = np.array([val.split(&#34;+&#34;)[1] for val in pos_raw])
    ra = []
    dec = []
    for ii,val in enumerate(ra_raw):
        if val[1:3] == &#39;24&#39;:
            rah = &#39;00&#39;
        else:
            rah = val[1:3]
        ra.append(f&#34;{rah}h{val[3:5]}m{val[5:]}s&#34;)
        dec.append(f&#34;{dec_raw[ii][:2]}d{dec_raw[ii][2:4]}m{dec_raw[ii][4:]}s&#34;)
    ra = np.array(ra)
    dec = np.array(dec)
    c = SkyCoord(ra, dec, frame=&#39;icrs&#39;)#.directional_offset_by(45*u.deg, 0.75*u.deg)
    return fname, c</code></pre>
</details>
</dd>
<dt id="everystamp.downloaders.VLASSDownloader.get_tiles"><code class="name flex">
<span>def <span class="ident">get_tiles</span></span>(<span>self, summary_file='VLASS_dyn_summary.php')</span>
</code></dt>
<dd>
<div class="desc"><p>Read tiles from tile catalog. If file missing, try wget <a href="https://archive-new.nrao.edu/vlass/VLASS_dyn_summary.php">https://archive-new.nrao.edu/vlass/VLASS_dyn_summary.php</a></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>summary_file</code></strong> :&ensp;<code>str</code></dt>
<dd>Location where the VLASS summary file is located.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>tab</code></strong> :&ensp;<code>astropy Table</code></dt>
<dd>Table containing tile information.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_tiles(self, summary_file=&#39;VLASS_dyn_summary.php&#39;):
    &#39;&#39;&#39;
    Read tiles from tile catalog. If file missing, try wget https://archive-new.nrao.edu/vlass/VLASS_dyn_summary.php

    Parameters
    ----------
    summary_file : str
        Location where the VLASS summary file is located.

    Returns
    -------
    tab : astropy Table
        Table containing tile information.
    &#39;&#39;&#39;
    if not os.path.isfile(summary_file):
        self.logger.warn(f&#39;Could not find VLASS summary file {summary_file}!&#39;)
        self.logger.info(&#39;Attempting to download VLASS summary file&#39;)
        subprocess.run([&#39;wget&#39;, &#39;https://archive-new.nrao.edu/vlass/VLASS_dyn_summary.php&#39;, &#39;-O&#39;, summary_file])
    
    # Put it in a more managable format by replacing consecutive white space with commas.
    # Assumes no more than 1 space in valid entries.
    subprocess.run([&#39;sed&#39;, &#39;-i&#39;, &#39;-e&#39;, r&#39;s/ \{2,\}/,/g&#39;, summary_file], check=True)

    tab = Table.read(summary_file, data_start=3, format=&#39;ascii.csv&#39;)
    tab.rename_column(&#39;Observing&#39;, &#39;Epoch&#39;)
    tab.rename_column(&#39;Observation&#39;, &#39;Date&#39;)
    return tab</code></pre>
</details>
</dd>
<dt id="everystamp.downloaders.VLASSDownloader.search_tiles"><code class="name flex">
<span>def <span class="ident">search_tiles</span></span>(<span>self, tiles, c)</span>
</code></dt>
<dd>
<div class="desc"><p>Search the tile catalog for tiles containing the input coordinate</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tiles</code></strong> :&ensp;<code>astropy Table</code></dt>
<dd>Tile catalogue as obtained from get_tiles()</dd>
<dt><strong><code>c</code></strong> :&ensp;<code>SkyCoord</code></dt>
<dd>Location to check for coverage in one of the observed tiles.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tile name : str</code></dt>
<dd>Best matching tile.</dd>
<dt><code>observing epoch : str</code></dt>
<dd>Epoch the best matching tile was observed in.</dd>
<dt><code>observing date : str</code></dt>
<dd>Date the best matching tile was observed at.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def search_tiles(self, tiles, c):
    &#39;&#39;&#39; Search the tile catalog for tiles containing the input coordinate

    Parameters
    ----------
    tiles : astropy Table
        Tile catalogue as obtained from get_tiles()
    c : SkyCoord
        Location to check for coverage in one of the observed tiles.

    Returns
    -------
    tile name : str
        Best matching tile.
    observing epoch : str
        Epoch the best matching tile was observed in.
    observing date : str
        Date the best matching tile was observed at.
    &#39;&#39;&#39;
    ra_h = c.ra.hour
    dec_d = c.dec.deg

    has_dec = np.logical_and(dec_d &gt;= tiles[&#39;Dec min&#39;], dec_d &lt; tiles[&#39;Dec max&#39;])
    has_ra = np.logical_and(ra_h &gt;= tiles[&#39;RA min&#39;], ra_h &lt; tiles[&#39;RA max&#39;])
    in_tile = np.logical_and(has_ra, has_dec)
    name = tiles[&#39;Tile&#39;][in_tile]
    epoch = tiles[&#39;Epoch&#39;][in_tile]
    date = tiles[&#39;Date&#39;][in_tile]    
    if len(name) == 0:
        raise IndexError(&#34;Zero VLASS tiles available for the given coordinate&#34;)
    c_grid = SkyCoord(7.5*(tiles[&#39;RA min&#39;][in_tile] + tiles[&#39;RA max&#39;][in_tile]), 0.5 * (tiles[&#39;Dec min&#39;][in_tile] + tiles[&#39;Dec max&#39;][in_tile]), unit=&#39;deg&#39;, frame=&#39;icrs&#39;)
    dist = c_grid.separation(c)
    best_idx = np.argmin(dist)
    return name[best_idx], epoch[best_idx], date[best_idx]</code></pre>
</details>
</dd>
<dt id="everystamp.downloaders.VLASSDownloader.search_vlass"><code class="name flex">
<span>def <span class="ident">search_vlass</span></span>(<span>self, c, crop=False, crop_scale=256, consider_QA_rejected=False, ddir='/home/frits/testeverystamp')</span>
</code></dt>
<dd>
<div class="desc"><p>Searches the VLASS catalog for a source</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>c</code></strong> :&ensp;<code>astropy SkyCoord</code></dt>
<dd>Coordinate to search for in tiles.</dd>
<dt><strong><code>crop</code></strong> :&ensp;<code>bool</code></dt>
<dd>Make a cropped cutout of the area of interest.</dd>
<dt><strong><code>crop_scale</code></strong> :&ensp;<code>int</code></dt>
<dd>Crop the cutout to this amount of pixels centred around c.</dd>
<dt><strong><code>consider_QA_rejected</code></strong> :&ensp;<code>bool</code></dt>
<dd>Also consider tiles that failed the Quality Assurance checks.</dd>
<dt><strong><code>ddir</code></strong> :&ensp;<code>str</code></dt>
<dd>Location to download the cutout to.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>imname</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the output image.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def search_vlass(self, c, crop=False, crop_scale=256, consider_QA_rejected=False, ddir=os.getcwd()):
    &#34;&#34;&#34; 
    Searches the VLASS catalog for a source

    Parameters
    ----------
    c : astropy SkyCoord
        Coordinate to search for in tiles.
    crop : bool
        Make a cropped cutout of the area of interest.
    crop_scale : int
        Crop the cutout to this amount of pixels centred around c.
    consider_QA_rejected : bool
        Also consider tiles that failed the Quality Assurance checks.
    ddir : str
        Location to download the cutout to.

    Returns
    -------
    imname : str
        Name of the output image.
    &#34;&#34;&#34;
    # Find the VLASS tile
    tiles = self.get_tiles()
    tilename, epoch, obsdate = self.search_tiles(tiles, c)

    subtiles, c_tiles = self.get_subtiles(tilename, epoch, consider_QA_rejected)
    dist = c.separation(c_tiles)
    subtile = subtiles[np.argmin(dist)]

    imname = f&#34;{subtile[:-1]}.I.iter1.image.pbcor.tt0.subim.fits&#34;
    if len(glob.glob(imname)) == 0:
        if &#39;2.1&#39; in epoch:
            url_get = f&#34;https://archive-new.nrao.edu/vlass/quicklook/{epoch}/{tilename}/{subtile}&#34;
        else:
            url_get = f&#34;https://archive-new.nrao.edu/vlass/quicklook/{epoch}v2/{tilename}/{subtile}&#34;
        fname = f&#34;{url_get}{imname}&#34;
        self.logger.info(&#39;Downloading to &#39; + ddir)
        self.download_file(fname, target_dir=ddir)
        if consider_QA_rejected:
            if &#39;2.1&#39; in epoch:
                url_get = f&#34;https://archive-new.nrao.edu/vlass/quicklook/{epoch}/QA_REJECTED/{subtile}&#34;
            else:
                url_get = f&#34;https://archive-new.nrao.edu/vlass/quicklook/{epoch}v2/QA_REJECTED/{subtile}&#34;
            fname = f&#34;{url_get}{imname}&#34;
            self.download_file(fname, target_dir=ddir)
    if crop:    
        out = self.get_cutout(os.path.join(ddir, imname), c, crop_scale=crop_scale)
        return out
    else:
        return imname</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="everystamp.downloaders.FileDownloader" href="#everystamp.downloaders.FileDownloader">FileDownloader</a></b></code>:
<ul class="hlist">
<li><code><a title="everystamp.downloaders.FileDownloader.download_file" href="#everystamp.downloaders.FileDownloader.download_file">download_file</a></code></li>
<li><code><a title="everystamp.downloaders.FileDownloader.get_url_filename" href="#everystamp.downloaders.FileDownloader.get_url_filename">get_url_filename</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="everystamp.downloaders.VODownloader"><code class="flex name class">
<span>class <span class="ident">VODownloader</span></span>
<span>(</span><span>url, name='')</span>
</code></dt>
<dd>
<div class="desc"><p>Downloader sub-class for surveys offeret through a VO.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VODownloader():
    &#39;&#39;&#39; Downloader sub-class for surveys offeret through a VO.
    &#39;&#39;&#39;
    def __init__(self, url, name=&#39;&#39;):
        if not url:
            raise ValueError(&#39;VO url cannot be empty.&#39;)
        else:
            self.url = url
        if not name:
            self.name = self.url
            self.logger = logging.getLogger(&#39;EveryStamp:VODownloader&#39;)
        else:
            self.name = name
            self.logger = logging.getLogger(&#39;EveryStamp:VODownloader[{:s}]&#39;.format(self.name))

    def download(self, ra=0.0, dec=0.0, size=0.1, ddir=os.getcwd(), suffix=&#39;&#39;):
        &#39;&#39;&#39; Download a cutout from the VLASS survey.

        Parameters
        ----------
        ra : float
            Right ascension of the coordinate of interest in degrees.
        dec : float
            Declination of the coordinate of interest in degrees    .
        size : float
            Size of the area of interest in degrees.
        ddir : str
            Location to download the cutout to.
        &#39;&#39;&#39;
        c = SkyCoord(ra, dec, unit=&#39;deg&#39;)
        
        vo = pyvo.sia.SIAService(self.url)
        query = vo.search(c, size=size)
        if not query:
            raise ValueError(&#39;Requested coordinates not covered by the specified VO!&#39;)
        im = query.getrecord(0)
        if im.format == &#39;image/fits&#39;:
            self.logger.info(&#39;Downloading cutout from {:s}&#39;.format(self.name))
            im.cachedataset(os.path.join(ddir, &#39;{:s}_{:.4f}_{:.4f}_{:.3f}.fits&#39;.format(self.name, ra, dec, size)))</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="everystamp.downloaders.VODownloader.download"><code class="name flex">
<span>def <span class="ident">download</span></span>(<span>self, ra=0.0, dec=0.0, size=0.1, ddir='/home/frits/testeverystamp', suffix='')</span>
</code></dt>
<dd>
<div class="desc"><p>Download a cutout from the VLASS survey.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ra</code></strong> :&ensp;<code>float</code></dt>
<dd>Right ascension of the coordinate of interest in degrees.</dd>
<dt><strong><code>dec</code></strong> :&ensp;<code>float</code></dt>
<dd>Declination of the coordinate of interest in degrees
.</dd>
<dt><strong><code>size</code></strong> :&ensp;<code>float</code></dt>
<dd>Size of the area of interest in degrees.</dd>
<dt><strong><code>ddir</code></strong> :&ensp;<code>str</code></dt>
<dd>Location to download the cutout to.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def download(self, ra=0.0, dec=0.0, size=0.1, ddir=os.getcwd(), suffix=&#39;&#39;):
    &#39;&#39;&#39; Download a cutout from the VLASS survey.

    Parameters
    ----------
    ra : float
        Right ascension of the coordinate of interest in degrees.
    dec : float
        Declination of the coordinate of interest in degrees    .
    size : float
        Size of the area of interest in degrees.
    ddir : str
        Location to download the cutout to.
    &#39;&#39;&#39;
    c = SkyCoord(ra, dec, unit=&#39;deg&#39;)
    
    vo = pyvo.sia.SIAService(self.url)
    query = vo.search(c, size=size)
    if not query:
        raise ValueError(&#39;Requested coordinates not covered by the specified VO!&#39;)
    im = query.getrecord(0)
    if im.format == &#39;image/fits&#39;:
        self.logger.info(&#39;Downloading cutout from {:s}&#39;.format(self.name))
        im.cachedataset(os.path.join(ddir, &#39;{:s}_{:.4f}_{:.4f}_{:.3f}.fits&#39;.format(self.name, ra, dec, size)))</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="everystamp" href="index.html">everystamp</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="everystamp.downloaders.FileDownloader" href="#everystamp.downloaders.FileDownloader">FileDownloader</a></code></h4>
<ul class="">
<li><code><a title="everystamp.downloaders.FileDownloader.download_file" href="#everystamp.downloaders.FileDownloader.download_file">download_file</a></code></li>
<li><code><a title="everystamp.downloaders.FileDownloader.get_url_filename" href="#everystamp.downloaders.FileDownloader.get_url_filename">get_url_filename</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="everystamp.downloaders.HiPSDownloader" href="#everystamp.downloaders.HiPSDownloader">HiPSDownloader</a></code></h4>
<ul class="">
<li><code><a title="everystamp.downloaders.HiPSDownloader.download" href="#everystamp.downloaders.HiPSDownloader.download">download</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="everystamp.downloaders.LegacyDownloader" href="#everystamp.downloaders.LegacyDownloader">LegacyDownloader</a></code></h4>
<ul class="">
<li><code><a title="everystamp.downloaders.LegacyDownloader.download" href="#everystamp.downloaders.LegacyDownloader.download">download</a></code></li>
<li><code><a title="everystamp.downloaders.LegacyDownloader.format_url" href="#everystamp.downloaders.LegacyDownloader.format_url">format_url</a></code></li>
<li><code><a title="everystamp.downloaders.LegacyDownloader.logger" href="#everystamp.downloaders.LegacyDownloader.logger">logger</a></code></li>
<li><code><a title="everystamp.downloaders.LegacyDownloader.supported_keywords" href="#everystamp.downloaders.LegacyDownloader.supported_keywords">supported_keywords</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="everystamp.downloaders.PanSTARRSDownloader" href="#everystamp.downloaders.PanSTARRSDownloader">PanSTARRSDownloader</a></code></h4>
<ul class="">
<li><code><a title="everystamp.downloaders.PanSTARRSDownloader.download" href="#everystamp.downloaders.PanSTARRSDownloader.download">download</a></code></li>
<li><code><a title="everystamp.downloaders.PanSTARRSDownloader.psdownloader" href="#everystamp.downloaders.PanSTARRSDownloader.psdownloader">psdownloader</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="everystamp.downloaders.SkyViewDownloader" href="#everystamp.downloaders.SkyViewDownloader">SkyViewDownloader</a></code></h4>
<ul class="">
<li><code><a title="everystamp.downloaders.SkyViewDownloader.download" href="#everystamp.downloaders.SkyViewDownloader.download">download</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="everystamp.downloaders.VLASSDownloader" href="#everystamp.downloaders.VLASSDownloader">VLASSDownloader</a></code></h4>
<ul class="two-column">
<li><code><a title="everystamp.downloaders.VLASSDownloader.download" href="#everystamp.downloaders.VLASSDownloader.download">download</a></code></li>
<li><code><a title="everystamp.downloaders.VLASSDownloader.get_cutout" href="#everystamp.downloaders.VLASSDownloader.get_cutout">get_cutout</a></code></li>
<li><code><a title="everystamp.downloaders.VLASSDownloader.get_subtiles" href="#everystamp.downloaders.VLASSDownloader.get_subtiles">get_subtiles</a></code></li>
<li><code><a title="everystamp.downloaders.VLASSDownloader.get_tiles" href="#everystamp.downloaders.VLASSDownloader.get_tiles">get_tiles</a></code></li>
<li><code><a title="everystamp.downloaders.VLASSDownloader.search_tiles" href="#everystamp.downloaders.VLASSDownloader.search_tiles">search_tiles</a></code></li>
<li><code><a title="everystamp.downloaders.VLASSDownloader.search_vlass" href="#everystamp.downloaders.VLASSDownloader.search_vlass">search_vlass</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="everystamp.downloaders.VODownloader" href="#everystamp.downloaders.VODownloader">VODownloader</a></code></h4>
<ul class="">
<li><code><a title="everystamp.downloaders.VODownloader.download" href="#everystamp.downloaders.VODownloader.download">download</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>